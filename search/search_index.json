{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"GHA/","text":"Advanced GitHub Actions - Tips & Tricks GitHub Actions is a CI/CD tool that is in active development by GitHub. Because of this, while it is very easy to get started, it can sometimes be challenging to sift through outdated StackOverflow articles to do a specific thing, if you even know it exists! While the GitHub Actions documentation is fantastic, you have to know what's there and what's been added since you've looked last. This post attempts to resolve the issue by existing as a living document that gathers advanced features and explanations all in one place. Our team follows the GitHub Actions RSS feed to always be looped into the new features coming out. By knowing what's possible and how to achieve it, your CI/CD workflows will reach their greatest potential. Table of Contents Workflow Dispatch - Manual Triggering of Workflows Repository Dispatch - Triggering Another Workflow Repository Dispatch - Polling for Run Custom Actions vs Reusable Workflows Pausing a Pipeline - Manual Approval Dynamic, Multi-Dimensional Matrix Publishing Images to GitHub Package - Advanced Labels","title":"Overview"},{"location":"GHA/#advanced-github-actions-tips-tricks","text":"GitHub Actions is a CI/CD tool that is in active development by GitHub. Because of this, while it is very easy to get started, it can sometimes be challenging to sift through outdated StackOverflow articles to do a specific thing, if you even know it exists! While the GitHub Actions documentation is fantastic, you have to know what's there and what's been added since you've looked last. This post attempts to resolve the issue by existing as a living document that gathers advanced features and explanations all in one place. Our team follows the GitHub Actions RSS feed to always be looped into the new features coming out. By knowing what's possible and how to achieve it, your CI/CD workflows will reach their greatest potential.","title":"Advanced GitHub Actions - Tips &amp; Tricks"},{"location":"GHA/#table-of-contents","text":"Workflow Dispatch - Manual Triggering of Workflows Repository Dispatch - Triggering Another Workflow Repository Dispatch - Polling for Run Custom Actions vs Reusable Workflows Pausing a Pipeline - Manual Approval Dynamic, Multi-Dimensional Matrix Publishing Images to GitHub Package - Advanced Labels","title":"Table of Contents"},{"location":"GHA/topics/approval/","text":"Pausing a Pipeline - Manual Approval One of the features a lot of CI tools have is the ability to wait for manual approval to move to the next step in a workflow. This section will go over the functionality that GitHub does have to meet this need, and some of the downsides of it. Deployment reviews are currently the only way to introduce a manual pause into your pipeline. As it states in the name, this is less about an arbitrary pause and more about reviewing the pipeline results before a deployment. As such, the functionality is tied to other GitHub features such as environments . Put as simply as possible, instead of setting up a manual approval step in your workflow, you will create Environments in your repository that require reviewers to approve workflows for that environment. So, let's say you have a workflow with jobs A , B and C , and you want to pause your workflow before C runs. In that case, you'd make an environment for C that requires reviewer approval. When any workflow run gets to job C , an email will be sent out to all of the reviewers, and the workflow will pause until the reviewers approve. This is especially messy because at the time of this writing, GitHub does not provide Environments to non-public repositories in the free plan.","title":"Pausing a Pipeline: Manual Approval"},{"location":"GHA/topics/approval/#pausing-a-pipeline-manual-approval","text":"One of the features a lot of CI tools have is the ability to wait for manual approval to move to the next step in a workflow. This section will go over the functionality that GitHub does have to meet this need, and some of the downsides of it. Deployment reviews are currently the only way to introduce a manual pause into your pipeline. As it states in the name, this is less about an arbitrary pause and more about reviewing the pipeline results before a deployment. As such, the functionality is tied to other GitHub features such as environments . Put as simply as possible, instead of setting up a manual approval step in your workflow, you will create Environments in your repository that require reviewers to approve workflows for that environment. So, let's say you have a workflow with jobs A , B and C , and you want to pause your workflow before C runs. In that case, you'd make an environment for C that requires reviewer approval. When any workflow run gets to job C , an email will be sent out to all of the reviewers, and the workflow will pause until the reviewers approve. This is especially messy because at the time of this writing, GitHub does not provide Environments to non-public repositories in the free plan.","title":"Pausing a Pipeline - Manual Approval"},{"location":"GHA/topics/custom-actions/","text":"Custom Actions vs Reusable Workflows One of the things we see with people getting started with GitHub Actions is confusion around creating an action vs creating a reusable workflow. They have two distinct use-cases, but often they can be use together to make a powerful solution. Reusable Workflows You can think of reusable workflows as templates of workflows. A critical thing to know about them is that they are not triggered directly, but rather are referenced in another workflow. When a workflow uses a reusable flow, GitHub behind-the-scenes actually downloads it and runs it. This leads to the next most important thing to note--the reusable workflow actually executes in the context of the caller . This has very important ramifications, as seen in the example below: Repository A has reusable workflow X reusable workflow X references a GitHub Secret ${{ secrets.password }} Repository B has workflow Y When workflow Y is triggered, it calls the reusable flow X , which references ${{ secrets.password }} . And here we come to it--even though reusable flow X lives in repository A , because it's executing in the context of repository B , repository B must have defined the secret ${{ secrets.password }} . Put another way, the reusable workflow brings no state with it when called. The fact that reusable workflows bring no state can be challenging. For example, you cannot directly include helper script files alongside your reusable workflow. In addition, it means that the the caller of your reusable workflow must have all of the information necessary to execute it. This can make some security practices challenging, such as if you'd like your reusable workflow to perform encryption or signing of data, those secret keys must be distributed, or accessible to, to all repositories that will use the flow. Example Reusable Flow Workflow that calls Reusable Flow In the case of the example above, you can see the caller workflow calling the reusable flow below. Take note how you can see the reusable workflow steps and output just as if it were the workflow you triggered yourself: Custom Actions Custom Actions are probably more common than Reusable Flows, as GitHub Actions promotes them right when you get started using it. Any of the actions created and available on the GitHub Marketplace are all Custom Actions created by someone else. At it's core, a Custom Action is just a wrapper around some code. Since you're reading this though, you're more likely interested in creating your own Custom Actions. Beyond the basic documentation for creating a custom action , a key difference between them and Reusable Workflows is that when using an action, you automatically have access to all of the files in the custom action . This means that if you want the Custom Action to be comprised of multiple Javascript files, or even stateful JSON data, it will all available when called. Custom Actions currently can happen in two forms: A dedicated repository A folder in an existing repository Dedicated Repository Action These type of actions are what you see in the GitHub marketplace. They will always have a top level action.yml file such as this one for stale issues . To use them, you can simply use the following syntax: jobs: stale: runs-on: ubuntu-latest steps: - uses: actions/stale@v6 with: stale-issue-message: 'Stale issue message' ... Where actions/stale@v6 references the action in the format @ . You can create your own custom action the same way, and you do not need to publish it to the marketplace to use it. However, keep in mind the GitHub Custom Action repository must either be public , or the repository you are using it from must have proper access (i.e. it's internal and in the same organization). We will omit an example from this section as it's basic functionality for GitHub Actions. Directory-based Action If you run into a scenario where you'd prefer to house multiple Custom Actions in the same repository, or maybe modularize your code by having a Custom Action in the same repository as your workflow, you can also store the action anywhere in a repository. The key here is that the repository that holds the Custom Action must be checked out prior to use . To use a Custom Action in this manner, the syntax is as follows: jobs: stale: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Run Custom Action uses: ./.github/actions/custom-action Where ./.github/actions/custom-action is a folder in the repository and is structured according to the documentation for creating a custom action . Example Custom Action Workflow that calls Custom Action In the case of the example above, you can see the output of the Custom Action here:","title":"Custom Actions vs Reusable Workflows"},{"location":"GHA/topics/custom-actions/#custom-actions-vs-reusable-workflows","text":"One of the things we see with people getting started with GitHub Actions is confusion around creating an action vs creating a reusable workflow. They have two distinct use-cases, but often they can be use together to make a powerful solution.","title":"Custom Actions vs Reusable Workflows"},{"location":"GHA/topics/custom-actions/#reusable-workflows","text":"You can think of reusable workflows as templates of workflows. A critical thing to know about them is that they are not triggered directly, but rather are referenced in another workflow. When a workflow uses a reusable flow, GitHub behind-the-scenes actually downloads it and runs it. This leads to the next most important thing to note--the reusable workflow actually executes in the context of the caller . This has very important ramifications, as seen in the example below: Repository A has reusable workflow X reusable workflow X references a GitHub Secret ${{ secrets.password }} Repository B has workflow Y When workflow Y is triggered, it calls the reusable flow X , which references ${{ secrets.password }} . And here we come to it--even though reusable flow X lives in repository A , because it's executing in the context of repository B , repository B must have defined the secret ${{ secrets.password }} . Put another way, the reusable workflow brings no state with it when called. The fact that reusable workflows bring no state can be challenging. For example, you cannot directly include helper script files alongside your reusable workflow. In addition, it means that the the caller of your reusable workflow must have all of the information necessary to execute it. This can make some security practices challenging, such as if you'd like your reusable workflow to perform encryption or signing of data, those secret keys must be distributed, or accessible to, to all repositories that will use the flow.","title":"Reusable Workflows"},{"location":"GHA/topics/custom-actions/#example","text":"Reusable Flow Workflow that calls Reusable Flow In the case of the example above, you can see the caller workflow calling the reusable flow below. Take note how you can see the reusable workflow steps and output just as if it were the workflow you triggered yourself:","title":"Example"},{"location":"GHA/topics/custom-actions/#custom-actions","text":"Custom Actions are probably more common than Reusable Flows, as GitHub Actions promotes them right when you get started using it. Any of the actions created and available on the GitHub Marketplace are all Custom Actions created by someone else. At it's core, a Custom Action is just a wrapper around some code. Since you're reading this though, you're more likely interested in creating your own Custom Actions. Beyond the basic documentation for creating a custom action , a key difference between them and Reusable Workflows is that when using an action, you automatically have access to all of the files in the custom action . This means that if you want the Custom Action to be comprised of multiple Javascript files, or even stateful JSON data, it will all available when called. Custom Actions currently can happen in two forms: A dedicated repository A folder in an existing repository","title":"Custom Actions"},{"location":"GHA/topics/custom-actions/#dedicated-repository-action","text":"These type of actions are what you see in the GitHub marketplace. They will always have a top level action.yml file such as this one for stale issues . To use them, you can simply use the following syntax: jobs: stale: runs-on: ubuntu-latest steps: - uses: actions/stale@v6 with: stale-issue-message: 'Stale issue message' ... Where actions/stale@v6 references the action in the format @ . You can create your own custom action the same way, and you do not need to publish it to the marketplace to use it. However, keep in mind the GitHub Custom Action repository must either be public , or the repository you are using it from must have proper access (i.e. it's internal and in the same organization). We will omit an example from this section as it's basic functionality for GitHub Actions.","title":"Dedicated Repository Action"},{"location":"GHA/topics/custom-actions/#directory-based-action","text":"If you run into a scenario where you'd prefer to house multiple Custom Actions in the same repository, or maybe modularize your code by having a Custom Action in the same repository as your workflow, you can also store the action anywhere in a repository. The key here is that the repository that holds the Custom Action must be checked out prior to use . To use a Custom Action in this manner, the syntax is as follows: jobs: stale: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Run Custom Action uses: ./.github/actions/custom-action Where ./.github/actions/custom-action is a folder in the repository and is structured according to the documentation for creating a custom action .","title":"Directory-based Action"},{"location":"GHA/topics/custom-actions/#example_1","text":"Custom Action Workflow that calls Custom Action In the case of the example above, you can see the output of the Custom Action here:","title":"Example"},{"location":"GHA/topics/matrix/","text":"Dynamic, Multi-dimensional Matrix GitHub Actions uses the concept of a matrix run multiple instances of a job with different parameters. As with the rest of this article, you should already be familiar with the basics of a matrix job . This section will detail some advanced usages you may not have realized are possible! The documentation focuses heavily on static matrices, such as defining a list of hard-coded strings or integers in the pipeline and iterating the matrix over that. However, the main power comes in the dynamic aspect of it. They recently did add an example of using a context to define a matrix in this example , but we can take it a step further! What if we wanted a multi-dimensional matrix that was also dynamic? Well, it's possible to define a job in the following manner: run-matrix: runs-on: ubuntu-latest needs: - generate-matrix strategy: matrix: ${{ fromJSON(needs.generate-matrix.outputs.matrix) }} Notice above, how we only define matrix.strategy , but do not define any key/value pairs under it. Now, let's explore further into the steps on how you could use this: run-matrix: runs-on: ubuntu-latest needs: - generate-matrix strategy: matrix: ${{ fromJSON(needs.generate-matrix.outputs.matrix) }} steps: - name: Print run: echo \"The Color ${{ matrix.text_color }} is Hex ${{ matrix.hex_color }}. Now you can see the power of this, which is it's ability to take in a fully dynamic array of objects and run a matrix against them. There is one catch though, you must make sure you format the dynamic syntax properly. When doing a multi-dimensional matrix, here is the following format: jobs: includes_only: runs-on: ubuntu-latest strategy: matrix: include: - site: \"production\" datacenter: \"site-a\" - site: \"staging\" datacenter: \"site-b\" So if we want to do this dynamically, need to generate JSON exactly like: include: - site: \"production\" datacenter: \"site-a\" - site: \"staging\" datacenter: \"site-b\" Example Here is a working example of a fully dynamic matrix: Workflow With the following results, a pipeline that ran 3 times for each of the colors: And outputs inside each matrix job as follows:","title":"Dynamic, Multi-Dimensional Matrix"},{"location":"GHA/topics/matrix/#dynamic-multi-dimensional-matrix","text":"GitHub Actions uses the concept of a matrix run multiple instances of a job with different parameters. As with the rest of this article, you should already be familiar with the basics of a matrix job . This section will detail some advanced usages you may not have realized are possible! The documentation focuses heavily on static matrices, such as defining a list of hard-coded strings or integers in the pipeline and iterating the matrix over that. However, the main power comes in the dynamic aspect of it. They recently did add an example of using a context to define a matrix in this example , but we can take it a step further! What if we wanted a multi-dimensional matrix that was also dynamic? Well, it's possible to define a job in the following manner: run-matrix: runs-on: ubuntu-latest needs: - generate-matrix strategy: matrix: ${{ fromJSON(needs.generate-matrix.outputs.matrix) }} Notice above, how we only define matrix.strategy , but do not define any key/value pairs under it. Now, let's explore further into the steps on how you could use this: run-matrix: runs-on: ubuntu-latest needs: - generate-matrix strategy: matrix: ${{ fromJSON(needs.generate-matrix.outputs.matrix) }} steps: - name: Print run: echo \"The Color ${{ matrix.text_color }} is Hex ${{ matrix.hex_color }}. Now you can see the power of this, which is it's ability to take in a fully dynamic array of objects and run a matrix against them. There is one catch though, you must make sure you format the dynamic syntax properly. When doing a multi-dimensional matrix, here is the following format: jobs: includes_only: runs-on: ubuntu-latest strategy: matrix: include: - site: \"production\" datacenter: \"site-a\" - site: \"staging\" datacenter: \"site-b\" So if we want to do this dynamically, need to generate JSON exactly like: include: - site: \"production\" datacenter: \"site-a\" - site: \"staging\" datacenter: \"site-b\"","title":"Dynamic, Multi-dimensional Matrix"},{"location":"GHA/topics/matrix/#example","text":"Here is a working example of a fully dynamic matrix: Workflow With the following results, a pipeline that ran 3 times for each of the colors: And outputs inside each matrix job as follows:","title":"Example"},{"location":"GHA/topics/package-labels/","text":"Publishing Images to GitHub Package - Advanced Labels When using GitHub Actions to publish container images to GitHub Packages, the general use-case defined below just \"works\": Have one or more Dockerfile s in your repository Use the marketplace build-and-push action to build and push your image to your repositories Github Packages registry However, trying to use this flow while also modifying the images label metadata can cause unexpected behavior. While the default behavior is that the image you build via GitHub Actions will be published to that repositories package registry, if you specify the image label org.opencontainers.image.source as a different repository, the image will automatically be published to that repositories registry instead. This can also lead to build issues because now you will need a Personal Access Token instead of the auto-generated GITHUB_TOKEN to publish this image. Details about labelling of container images can be found here .","title":"Publishing Images to GitHub Package: Advanced Labels"},{"location":"GHA/topics/package-labels/#publishing-images-to-github-package-advanced-labels","text":"When using GitHub Actions to publish container images to GitHub Packages, the general use-case defined below just \"works\": Have one or more Dockerfile s in your repository Use the marketplace build-and-push action to build and push your image to your repositories Github Packages registry However, trying to use this flow while also modifying the images label metadata can cause unexpected behavior. While the default behavior is that the image you build via GitHub Actions will be published to that repositories package registry, if you specify the image label org.opencontainers.image.source as a different repository, the image will automatically be published to that repositories registry instead. This can also lead to build issues because now you will need a Personal Access Token instead of the auto-generated GITHUB_TOKEN to publish this image. Details about labelling of container images can be found here .","title":"Publishing Images to GitHub Package - Advanced Labels"},{"location":"GHA/topics/repository-dispatch-1/","text":"Repository Dispatch - Triggering Another Workflow You've learned a lot of the simple ways to trigger pipelines already: push pull_request workflow_dispatch But what about linking pipelines--having one pipeline trigger another? That is the job of a repository_dispatch , of which you can learn more about here . There are two parts to a repository_dispatch event: Creating a trigger event Listening for a trigger event Creating an Event To create an event, the simplest way is to just execute an HTTP POST command via curl . Here is the example that GitHub gives: curl \\ -X POST \\ -H \"Accept: application/vnd.github+json\" \\ -H \"Authorization: Bearer <YOUR-TOKEN>\" \\ https://api.github.com/repos/OWNER/REPO/dispatches \\ -d '{\"event_type\":\"on-demand-test\",\"client_payload\":{\"unit\":false,\"integration\":true}}' See the linked GitHub documentation above for requirements on generating the token to replace <YOUR-TOKEN> . Remember that the creator of this token must have privileges on the GitHub repository for which you'd like to trigger. Note also the data (denoted by -d line) here. There are two pieces of the json data: event_type - this is the webhook (trigger) name. Since you can have as many different repository_dispatch events as you want, differentiates them. As you'll see in listening for an event , a workflow can listen for as many repository_dispatch events as you wish. client_payload - this is any data to send to the workflow you wish to trigger. Often times, you'll want additional data to be sent such as results from the triggering pipeline. Listening for an Event Listening for a repository_dispatch event is as simple as adding it to the on: block of a workflow. You can listen for as many different dispatch events as you want, and handle them differently in your code. See the working example below for inspiration! Example Working code for this section: Triggering a repository_dispatch Listening for a repository_dispatch","title":"Repository Dispatch: Triggering Another Workflow"},{"location":"GHA/topics/repository-dispatch-1/#repository-dispatch-triggering-another-workflow","text":"You've learned a lot of the simple ways to trigger pipelines already: push pull_request workflow_dispatch But what about linking pipelines--having one pipeline trigger another? That is the job of a repository_dispatch , of which you can learn more about here . There are two parts to a repository_dispatch event: Creating a trigger event Listening for a trigger event","title":"Repository Dispatch - Triggering Another Workflow"},{"location":"GHA/topics/repository-dispatch-1/#creating-an-event","text":"To create an event, the simplest way is to just execute an HTTP POST command via curl . Here is the example that GitHub gives: curl \\ -X POST \\ -H \"Accept: application/vnd.github+json\" \\ -H \"Authorization: Bearer <YOUR-TOKEN>\" \\ https://api.github.com/repos/OWNER/REPO/dispatches \\ -d '{\"event_type\":\"on-demand-test\",\"client_payload\":{\"unit\":false,\"integration\":true}}' See the linked GitHub documentation above for requirements on generating the token to replace <YOUR-TOKEN> . Remember that the creator of this token must have privileges on the GitHub repository for which you'd like to trigger. Note also the data (denoted by -d line) here. There are two pieces of the json data: event_type - this is the webhook (trigger) name. Since you can have as many different repository_dispatch events as you want, differentiates them. As you'll see in listening for an event , a workflow can listen for as many repository_dispatch events as you wish. client_payload - this is any data to send to the workflow you wish to trigger. Often times, you'll want additional data to be sent such as results from the triggering pipeline.","title":"Creating an Event"},{"location":"GHA/topics/repository-dispatch-1/#listening-for-an-event","text":"Listening for a repository_dispatch event is as simple as adding it to the on: block of a workflow. You can listen for as many different dispatch events as you want, and handle them differently in your code. See the working example below for inspiration!","title":"Listening for an Event"},{"location":"GHA/topics/repository-dispatch-1/#example","text":"Working code for this section: Triggering a repository_dispatch Listening for a repository_dispatch","title":"Example"},{"location":"GHA/topics/repository-dispatch-2/","text":"Repository Dispatch - Polling for Run One of the biggest features lacking in the GitHub Actions space today is centered around repository_dispatch events. When a repository_dispatch is triggered via an API call, the response does not contain any return information, meaning that you as a developer have no way to know information including the success/failure/completion-time of the called workflow. You could consider just getting all of the recent runs triggered, but you're very much in a race condition world! Thanks to a newer feature GitHub Actions recently released, there is a viable workaround to this, although it's not pretty. What unlocks this possibility is somewhat obscure, and that's Dynamic names for workflow runs . Here's how Dynamic names help us solve our problem: Caller workflow generates some unique name, such as a UUID Caller workflow passes the UUID to the called workflow via it's client_payload data when triggering the repository_dispatch Called workflow uses the syntax run-name: ${{ github.event.client_payload.id }} , which dynamically names the workflow the UUID value. Caller, after triggering the repository_dispatch , now can poll the workflow runs to find one who's name is the UUID! Caller, once the workflow with the UUID is found, can either poll or use the GitHub CLI gh run watch to watch that run for it's completion results. Example Working code for this section: Triggering a repository_dispatch and polling Listening for a repository_dispatch using a dynamic name Polling script In the case of the example above, you can see a workflow get generated with a random ID:","title":"Repository Dispatch: Polling for Run"},{"location":"GHA/topics/repository-dispatch-2/#repository-dispatch-polling-for-run","text":"One of the biggest features lacking in the GitHub Actions space today is centered around repository_dispatch events. When a repository_dispatch is triggered via an API call, the response does not contain any return information, meaning that you as a developer have no way to know information including the success/failure/completion-time of the called workflow. You could consider just getting all of the recent runs triggered, but you're very much in a race condition world! Thanks to a newer feature GitHub Actions recently released, there is a viable workaround to this, although it's not pretty. What unlocks this possibility is somewhat obscure, and that's Dynamic names for workflow runs . Here's how Dynamic names help us solve our problem: Caller workflow generates some unique name, such as a UUID Caller workflow passes the UUID to the called workflow via it's client_payload data when triggering the repository_dispatch Called workflow uses the syntax run-name: ${{ github.event.client_payload.id }} , which dynamically names the workflow the UUID value. Caller, after triggering the repository_dispatch , now can poll the workflow runs to find one who's name is the UUID! Caller, once the workflow with the UUID is found, can either poll or use the GitHub CLI gh run watch to watch that run for it's completion results.","title":"Repository Dispatch - Polling for Run"},{"location":"GHA/topics/repository-dispatch-2/#example","text":"Working code for this section: Triggering a repository_dispatch and polling Listening for a repository_dispatch using a dynamic name Polling script In the case of the example above, you can see a workflow get generated with a random ID:","title":"Example"},{"location":"GHA/topics/workflow-dispatch/","text":"Workflow Dispatch - Manual Triggering of Workflows This is the simplest example here, and is really only included because the naming is a bit weird. A workflow_dispatch trigger is a manual trigger--the easiest way to manually kick off a workflow from the GitHub interface. After adding the workflow_dispatch trigger to your workflow, trigger your workflow by navigating to: Your GitHub Repository main page Click the \"Actions\" tab On the left bar, select the name of your workflow On the right side, there is a button Run workflow that allows you to trigger your workflow. Additional Inputs If you want to get even more enlightened, check out other options that go along with workflow_dispatch , such as adding inputs in the GitHub documentation . A great thing to note is that there is a default dropdown that appears, allowing you to select the branch to run from. GitHub Actions only knows about workflows that exist in the default branch . So if you're developing a new workflow on a feature branch and you want to manually trigger it, you'll find that the workflow doesn't show up on the Actions page! There are a couple ways around this: Change the default branch to the feature branch you are working on Start by creating a very simple workflow, similar to the example below, and getting that merged into your default branch , before actually developing the workflow We generally prefer the second option. Once the simple \"Hello World\" workflow is on the default branch , you can continue developing on your feature branch use the workflow_dispatch to trigger your updated code on the feature branch whenever you want using the dropdown! Example Check this workflow out for an example of creating a workflow_dispatch .","title":"Workflow Dispatch: Manual Triggering of Workflows"},{"location":"GHA/topics/workflow-dispatch/#workflow-dispatch-manual-triggering-of-workflows","text":"This is the simplest example here, and is really only included because the naming is a bit weird. A workflow_dispatch trigger is a manual trigger--the easiest way to manually kick off a workflow from the GitHub interface. After adding the workflow_dispatch trigger to your workflow, trigger your workflow by navigating to: Your GitHub Repository main page Click the \"Actions\" tab On the left bar, select the name of your workflow On the right side, there is a button Run workflow that allows you to trigger your workflow.","title":"Workflow Dispatch - Manual Triggering of Workflows"},{"location":"GHA/topics/workflow-dispatch/#additional-inputs","text":"If you want to get even more enlightened, check out other options that go along with workflow_dispatch , such as adding inputs in the GitHub documentation . A great thing to note is that there is a default dropdown that appears, allowing you to select the branch to run from. GitHub Actions only knows about workflows that exist in the default branch . So if you're developing a new workflow on a feature branch and you want to manually trigger it, you'll find that the workflow doesn't show up on the Actions page! There are a couple ways around this: Change the default branch to the feature branch you are working on Start by creating a very simple workflow, similar to the example below, and getting that merged into your default branch , before actually developing the workflow We generally prefer the second option. Once the simple \"Hello World\" workflow is on the default branch , you can continue developing on your feature branch use the workflow_dispatch to trigger your updated code on the feature branch whenever you want using the dropdown!","title":"Additional Inputs"},{"location":"GHA/topics/workflow-dispatch/#example","text":"Check this workflow out for an example of creating a workflow_dispatch .","title":"Example"}]}